diff -ruN ns-allinone-2.35/ns-2.35/mac/AK229MAC.cc ns-allinone-2.35_modified/ns-2.35/mac/AK229MAC.cc
--- ns-allinone-2.35/ns-2.35/mac/AK229MAC.cc	1969-12-31 19:00:00.000000000 -0500
+++ ns-allinone-2.35_modified/ns-2.35/mac/AK229MAC.cc	2016-12-16 15:57:07.348952000 -0500
@@ -0,0 +1,373 @@
+
+/*
+ * mac-simple.cc
+ * Copyright (C) 2003 by the University of Southern California
+ * $Id: mac-simple.cc,v 1.8 2010/03/08 05:54:52 tom_henderson Exp $
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
+ *
+ *
+ * The copyright of this module includes the following
+ * linking-with-specific-other-licenses addition:
+ *
+ * In addition, as a special exception, the copyright holders of
+ * this module give you permission to combine (via static or
+ * dynamic linking) this module with free software programs or
+ * libraries that are released under the GNU LGPL and with code
+ * included in the standard release of ns-2 under the Apache 2.0
+ * license or under otherwise-compatible licenses with advertising
+ * requirements (or modified versions of such code, with unchanged
+ * license).  You may copy and distribute such a system following the
+ * terms of the GNU GPL for this module and the licenses of the
+ * other code concerned, provided that you include the source code of
+ * that other code when and as the GNU GPL requires distribution of
+ * source code.
+ *
+ * Note that people who make modified versions of this module
+ * are not obligated to grant this special exception for their
+ * modified versions; it is their choice whether to do so.  The GNU
+ * General Public License gives permission to release a modified
+ * version without this exception; this exception also makes it
+ * possible to release a modified version which carries forward this
+ * exception.
+ *
+ */
+
+#include "ll.h"
+#include "mac.h"
+#include "AK229MAC.h"
+#include "random.h"
+
+#include "agent.h"
+#include "basetrace.h"
+
+#include "cmu-trace.h"
+
+static class AK229MACClass : public TclClass {
+public:
+    AK229MACClass() : TclClass("Mac/AK229MAC") {}
+    TclObject* create(int, const char*const*) {
+        return new AK229MAC();
+    }
+} class_AK229MAC;
+
+
+// Added by Sushmita to support event tracing (singal@nunki.usc.edu).
+void AK229MAC::trace_event(char *eventtype, Packet *p)
+{
+    if (et_ == NULL) return;
+    char *wrk = et_->buffer();
+    char *nwrk = et_->nbuffer();
+    
+    hdr_ip *iph = hdr_ip::access(p);
+    char *src_nodeaddr =
+    Address::instance().print_nodeaddr(iph->saddr());
+    char *dst_nodeaddr =
+    Address::instance().print_nodeaddr(iph->daddr());
+    
+    if (wrk != 0)
+    {
+        sprintf(wrk, "E -t "TIME_FORMAT" %s %s %s",
+                et_->round(Scheduler::instance().clock()),
+                eventtype,
+                src_nodeaddr,
+                dst_nodeaddr);
+    }
+    if (nwrk != 0)
+    {
+        sprintf(nwrk, "E -t "TIME_FORMAT" %s %s %s",
+                et_->round(Scheduler::instance().clock()),
+                eventtype,
+                src_nodeaddr,
+                dst_nodeaddr);
+    }
+    et_->dump();
+}
+
+AK229MAC::AK229MAC() : Mac() {
+    rx_state_ = tx_state_ = MAC_IDLE;
+    tx_active_ = 0;
+    waitTimer = new AK229MACWaitTimer(this);
+    sendTimer = new AK229MACSendTimer(this);
+    recvTimer = new AK229MACRecvTimer(this);
+    
+    bind("repeatTx_", &repeatTx_);
+    bind("interval_", &interval_);
+    et_ = new EventTrace();
+    busy_ = 0;
+    	bind("fullduplex_mode_", &fullduplex_mode_);
+}
+
+int
+AK229MAC::command(int argc, const char*const* argv)
+{
+    if (argc == 3) {
+        if(strcmp(argv[1], "eventtrace") == 0) {
+            et_ = (EventTrace *)TclObject::lookup(argv[2]);
+            return (TCL_OK);
+        }
+    }
+    return Mac::command(argc, argv);
+}
+
+void AK229MAC::recv(Packet *p, Handler *h) {
+    
+    struct hdr_cmn *hdr = HDR_CMN(p);
+    /* let MacSimple::send handle the outgoing packets */
+    if (hdr->direction() == hdr_cmn::DOWN) {
+        send(p,h);
+        return;
+    }
+    
+    
+    // in full duplex mode it can recv and send at the same time
+    if (!fullduplex_mode_ && tx_active_)
+    {
+        hdr->error() = 1;
+        
+    }
+    
+    
+    if (rx_state_ == MAC_IDLE) {
+        /*
+         * We aren't already receiving any packets, so go ahead
+         * and try to receive this one.
+         */
+        rx_state_ = MAC_RECV;
+        pktRx_ = p;
+        /* schedule reception of the packet */
+        recvTimer->start(txtime(p));
+    } else {
+        /*
+         * We are receiving a different packet, so decide whether
+         * the new packet's power is high enough to notice it.
+         */
+        if (pktRx_->txinfo_.RxPr / p->txinfo_.RxPr
+            >= p->txinfo_.CPThresh) {
+            /* power too low, ignore the packet */
+            Packet::free(p);
+        } else {
+            /* power is high enough to result in collision */
+            rx_state_ = MAC_COLL;
+            
+            /*
+             * look at the length of each packet and update the
+             * timer if necessary
+             */
+            
+            if (txtime(p) > recvTimer->expire()) {
+                recvTimer->stop();
+                Packet::free(pktRx_);
+                pktRx_ = p;
+                recvTimer->start(txtime(pktRx_));
+            } else {
+                Packet::free(p);
+            }
+        }
+    }
+}
+
+
+double
+AK229MAC::txtime(Packet *p)
+{
+    struct hdr_cmn *ch = HDR_CMN(p);
+    double t = ch->txtime();
+    if (t < 0.0)
+    t = 0.0;
+    return t;
+}
+
+
+
+void AK229MAC::send(Packet *p, Handler *h)
+{
+    hdr_cmn* ch = HDR_CMN(p);
+    
+    ch->txtime() = Mac::txtime(ch->size());
+    
+    trace_event("SENSING_CARRIER",p);
+    double max_delay = 0;
+    
+    double* delays = new double[repeatTx_];
+    
+    for (int i = 0; i < repeatTx_; i++) {
+        delays[i] = (rand() % 100) / 100.0 * interval_;
+        if (delays[i] > max_delay) {
+            max_delay = delays[i];
+        }
+    }
+    
+    for (int i = 0; i < repeatTx_; i++) {
+        if (delays[i] != max_delay) {
+            Scheduler::instance().schedule(this, (Event*)p->copy(), delays[i]);
+        }
+    }
+    delete delays;
+    
+    waitTimer->restart(max_delay);
+    
+    if (tx_state_ != MAC_IDLE) {
+        Packet::free(p);
+        return;
+    }
+    
+    pktTx_ = p;
+    txHandler_ = h;
+    // rather than sending packets out immediately, add in some
+    // jitter to reduce chance of unnecessary collisions
+//    double jitter = Random::random()%40 * 100/bandwidth_;
+    
+    if(rx_state_ != MAC_IDLE) {
+        trace_event("BACKING_OFF",p);
+    }
+    
+    if (rx_state_ == MAC_IDLE ) {
+        // we're idle, so start sending now
+        waitTimer->restart(max_delay);
+        sendTimer->restart(max_delay + ch->txtime());
+    } else {
+        // we're currently receiving, so schedule it after
+        // we finish receiving
+        waitTimer->restart(max_delay);
+        sendTimer->restart(max_delay + ch->txtime()
+                           + HDR_CMN(pktRx_)->txtime());
+    }
+}
+
+
+void AK229MAC::recvHandler()
+{
+    hdr_cmn *ch = HDR_CMN(pktRx_);
+    Packet* p = pktRx_;
+    MacState state = rx_state_;
+    pktRx_ = 0;
+    int dst = hdr_dst((char*)HDR_MAC(p));
+    
+    //busy_ = 0;
+    
+    rx_state_ = MAC_IDLE;
+    
+    // in full duplex mode we can send and recv at the same time
+    // as different chanels are used for tx and rx'ing
+    if (!fullduplex_mode_ && tx_active_) {
+        // we are currently sending, so discard packet
+        Packet::free(p);
+    } else if (state == MAC_COLL) {
+        // recv collision, so discard the packet
+        drop(p, DROP_MAC_COLLISION);
+        //Packet::free(p);
+    } else if (dst != index_ && (u_int32_t)dst != MAC_BROADCAST) {
+        
+        /*  address filtering
+         *  We don't want to log this event, so we just free
+         *  the packet instead of calling the drop routine.
+         */
+        Packet::free(p);
+    } else if (ch->error()) {
+        // packet has errors, so discard it
+        //Packet::free(p);
+        drop(p, DROP_MAC_PACKET_ERROR);
+        
+    } else {
+        uptarget_->recv(p, (Handler*) 0);
+    }
+}
+
+void AK229MAC::waitHandler()
+{
+    tx_state_ = MAC_SEND;
+    tx_active_ = 1;
+    
+    downtarget_->recv(pktTx_, txHandler_);
+}
+
+void AK229MAC::sendHandler()
+{
+    Handler *h = txHandler_;
+    Packet *p = pktTx_;
+    
+    pktTx_ = 0;
+    txHandler_ = 0;
+    tx_state_ = MAC_IDLE;
+    tx_active_ = 0;
+    
+    
+    h->handle(p);
+}
+
+
+void AK229MACTimer::restart(double time)
+{
+    if (busy_)
+    stop();
+    start(time);
+}
+
+
+
+void AK229MACTimer::start(double time)
+{
+    Scheduler &s = Scheduler::instance();
+    
+    assert(busy_ == 0);
+    
+    busy_ = 1;
+    stime = s.clock();
+    rtime = time;
+    assert(rtime >= 0.0);
+    
+    s.schedule(this, &intr, rtime);
+}
+
+void AK229MACTimer::stop(void)
+{
+    Scheduler &s = Scheduler::instance();
+    
+    assert(busy_);
+    s.cancel(&intr);
+    
+    busy_ = 0;
+    stime = rtime = 0.0;
+}
+
+
+void AK229MACWaitTimer::handle(Event *)
+{
+    busy_ = 0;
+    stime = rtime = 0.0;
+    
+    mac->waitHandler();
+}
+
+void AK229MACSendTimer::handle(Event *)
+{
+    busy_ = 0;
+    stime = rtime = 0.0;
+    
+    mac->sendHandler();
+}
+
+void AK229MACRecvTimer::handle(Event *)
+{
+    busy_ = 0;
+    stime = rtime = 0.0;
+    
+    mac->recvHandler();
+}
+
+void
+AK229MAC::handle(Event* p) {
+    downtarget_->recv((Packet*)p, txHandler_);
+}
diff -ruN ns-allinone-2.35/ns-2.35/mac/AK229MAC.h ns-allinone-2.35_modified/ns-2.35/mac/AK229MAC.h
--- ns-allinone-2.35/ns-2.35/mac/AK229MAC.h	1969-12-31 19:00:00.000000000 -0500
+++ ns-allinone-2.35_modified/ns-2.35/mac/AK229MAC.h	2016-12-16 16:26:01.071871000 -0500
@@ -0,0 +1,139 @@
+
+/*
+ * mac-simple.h
+ * Copyright (C) 2003 by the University of Southern California
+ * $Id: mac-simple.h,v 1.6 2005/08/25 18:58:07 johnh Exp $
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
+ *
+ *
+ * The copyright of this module includes the following
+ * linking-with-specific-other-licenses addition:
+ *
+ * In addition, as a special exception, the copyright holders of
+ * this module give you permission to combine (via static or
+ * dynamic linking) this module with free software programs or
+ * libraries that are released under the GNU LGPL and with code
+ * included in the standard release of ns-2 under the Apache 2.0
+ * license or under otherwise-compatible licenses with advertising
+ * requirements (or modified versions of such code, with unchanged
+ * license).  You may copy and distribute such a system following the
+ * terms of the GNU GPL for this module and the licenses of the
+ * other code concerned, provided that you include the source code of
+ * that other code when and as the GNU GPL requires distribution of
+ * source code.
+ *
+ * Note that people who make modified versions of this module
+ * are not obligated to grant this special exception for their
+ * modified versions; it is their choice whether to do so.  The GNU
+ * General Public License gives permission to release a modified
+ * version without this exception; this exception also makes it
+ * possible to release a modified version which carries forward this
+ * exception.
+ *
+ */
+
+#ifndef ns_mac_simple_h
+#define ns_mac_simple_h
+#include "address.h"
+#include "ip.h"
+
+class AK229MACWaitTimer;
+class AK229MACSendTimer;
+class AK229MACRecvTimer;
+class EventTrace;
+
+
+class AK229MAC : public Mac {
+    friend class BackoffTimer;
+public:
+    AK229MAC();
+    void recv(Packet *p, Handler *h);
+    void send(Packet *p, Handler *h);
+    void handle(Event* e);
+    
+    void waitHandler(void);
+    void sendHandler(void);
+    void recvHandler(void);
+    double txtime(Packet *p);
+    
+    void trace_event(char *, Packet *);
+    int command(int, const char*const*);
+    EventTrace *et_;
+    int repeatTx_;
+    double interval_;
+    
+private:
+    Packet *	pktRx_;
+    Packet *	pktTx_;
+    MacState        rx_state_;      // incoming state (MAC_RECV or MAC_IDLE)
+    MacState        tx_state_;      // outgoing state
+    int             tx_active_;
+    int             fullduplex_mode_;
+    Handler * 	txHandler_;
+    AK229MACWaitTimer *waitTimer;
+    AK229MACSendTimer *sendTimer;
+    AK229MACRecvTimer *recvTimer;
+    
+    int busy_ ;
+    
+    
+};
+
+class AK229MACTimer: public Handler {
+public:
+    AK229MACTimer(AK229MAC* m) : mac(m) {
+        busy_ = 0;
+    }
+    virtual void handle(Event *e) = 0;
+    virtual void restart(double time);
+    virtual void start(double time);
+    virtual void stop(void);
+    inline int busy(void) { return busy_; }
+    inline double expire(void) {
+        return ((stime + rtime) - Scheduler::instance().clock());
+    }
+    
+protected:
+    AK229MAC		*mac;
+    int		busy_;
+    Event		intr;
+    double		stime;
+    double		rtime;
+    double		slottime;
+};
+
+// Timer to use for delaying the sending of packets
+class AK229MACWaitTimer: public AK229MACTimer {
+public: AK229MACWaitTimer(AK229MAC *m) : AK229MACTimer(m) {}
+    void handle(Event *e);
+};
+
+//  Timer to use for finishing sending of packets
+class AK229MACSendTimer: public AK229MACTimer {
+public:
+    AK229MACSendTimer(AK229MAC *m) : AK229MACTimer(m) {}
+    void handle(Event *e);
+};
+
+// Timer to use for finishing reception of packets
+class AK229MACRecvTimer: public AK229MACTimer {
+public:
+    AK229MACRecvTimer(AK229MAC *m) : AK229MACTimer(m) {}
+    void handle(Event *e);
+};
+
+
+
+#endif
diff -ruN ns-allinone-2.35/ns-2.35/mac/AK229MAC.h~ ns-allinone-2.35_modified/ns-2.35/mac/AK229MAC.h~
--- ns-allinone-2.35/ns-2.35/mac/AK229MAC.h~	1969-12-31 19:00:00.000000000 -0500
+++ ns-allinone-2.35_modified/ns-2.35/mac/AK229MAC.h~	2016-12-16 16:10:22.334278000 -0500
@@ -0,0 +1,139 @@
+
+/*
+ * mac-simple.h
+ * Copyright (C) 2003 by the University of Southern California
+ * $Id: mac-simple.h,v 1.6 2005/08/25 18:58:07 johnh Exp $
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
+ *
+ *
+ * The copyright of this module includes the following
+ * linking-with-specific-other-licenses addition:
+ *
+ * In addition, as a special exception, the copyright holders of
+ * this module give you permission to combine (via static or
+ * dynamic linking) this module with free software programs or
+ * libraries that are released under the GNU LGPL and with code
+ * included in the standard release of ns-2 under the Apache 2.0
+ * license or under otherwise-compatible licenses with advertising
+ * requirements (or modified versions of such code, with unchanged
+ * license).  You may copy and distribute such a system following the
+ * terms of the GNU GPL for this module and the licenses of the
+ * other code concerned, provided that you include the source code of
+ * that other code when and as the GNU GPL requires distribution of
+ * source code.
+ *
+ * Note that people who make modified versions of this module
+ * are not obligated to grant this special exception for their
+ * modified versions; it is their choice whether to do so.  The GNU
+ * General Public License gives permission to release a modified
+ * version without this exception; this exception also makes it
+ * possible to release a modified version which carries forward this
+ * exception.
+ *
+ */
+
+#ifndef ns_mac_simple_h
+#define ns_mac_simple_h
+#include "address.h"
+#include "ip.h"
+
+class AK229MACWaitTimer;
+class AK229MACSendTimer;
+class AK229MACRecvTimer;
+class EventTrace;
+
+
+class AK229MAC : public Mac {
+    friend class BackoffTimer;
+public:
+    AK229MAC();
+    void recv(Packet *p, Handler *h);
+    void send(Packet *p, Handler *h);
+    void handle(Event* e);
+    
+    void waitHandler(void);
+    void sendHandler(void);
+    void recvHandler(void);
+    double txtime(Packet *p);
+    
+    void trace_event(char *, Packet *);
+    int command(int, const char*const*);
+    EventTrace *et_;
+    int repeatTx_;
+    double interval_;
+    
+private:
+    Packet *	pktRx_;
+    Packet *	pktTx_;
+    MacState        rx_state_;      // incoming state (MAC_RECV or MAC_IDLE)
+    MacState        tx_state_;      // outgoing state
+    int             tx_active_;
+    int             fullduplex_mode_;
+    Handler * 	txHandler_;
+    AK229WaitTimer *waitTimer;
+    AK229SendTimer *sendTimer;
+    AK229RecvTimer *recvTimer;
+    
+    int busy_ ;
+    
+    
+};
+
+class AK229MACTimer: public Handler {
+public:
+    AK229MACTimer(AK229MAC* m) : mac(m) {
+        busy_ = 0;
+    }
+    virtual void handle(Event *e) = 0;
+    virtual void restart(double time);
+    virtual void start(double time);
+    virtual void stop(void);
+    inline int busy(void) { return busy_; }
+    inline double expire(void) {
+        return ((stime + rtime) - Scheduler::instance().clock());
+    }
+    
+protected:
+    AK229MAC		*mac;
+    int		busy_;
+    Event		intr;
+    double		stime;
+    double		rtime;
+    double		slottime;
+};
+
+// Timer to use for delaying the sending of packets
+class AK229MACWaitTimer: public AK229MACTimer {
+public: AK229MACWaitTimer(AK229MAC *m) : AK229MACTimer(m) {}
+    void handle(Event *e);
+};
+
+//  Timer to use for finishing sending of packets
+class AK229MACSendTimer: public AK229MACTimer {
+public:
+    AK229MACSendTimer(AK229MAC *m) : AK229MACTimer(m) {}
+    void handle(Event *e);
+};
+
+// Timer to use for finishing reception of packets
+class AK229MACRecvTimer: public AK229MACTimer {
+public:
+    AK229MACRecvTimer(AK229MAC *m) : AK229MACTimer(m) {}
+    void handle(Event *e);
+};
+
+
+
+#endif
Binary files ns-allinone-2.35/ns-2.35/mac/AK229MAC.o and ns-allinone-2.35_modified/ns-2.35/mac/AK229MAC.o differ
diff -ruN ns-allinone-2.35/ns-2.35/mac/MAC_GRP11.cc ns-allinone-2.35_modified/ns-2.35/mac/MAC_GRP11.cc
--- ns-allinone-2.35/ns-2.35/mac/MAC_GRP11.cc	1969-12-31 19:00:00.000000000 -0500
+++ ns-allinone-2.35_modified/ns-2.35/mac/MAC_GRP11.cc	2016-12-18 22:32:56.047702000 -0500
@@ -0,0 +1,397 @@
+
+/*
+ * MAC_GRP11.cc
+ * Copyright (C) 2003 by the University of Southern California
+ * $Id: mac-simple.cc,v 1.8 2010/03/08 05:54:52 tom_henderson Exp $
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
+ *
+ *
+ * The copyright of this module includes the following
+ * linking-with-specific-other-licenses addition:
+ *
+ * In addition, as a special exception, the copyright holders of
+ * this module give you permission to combine (via static or
+ * dynamic linking) this module with free software programs or
+ * libraries that are released under the GNU LGPL and with code
+ * included in the standard release of ns-2 under the Apache 2.0
+ * license or under otherwise-compatible licenses with advertising
+ * requirements (or modified versions of such code, with unchanged
+ * license).  You may copy and distribute such a system following the
+ * terms of the GNU GPL for this module and the licenses of the
+ * other code concerned, provided that you include the source code of
+ * that other code when and as the GNU GPL requires distribution of
+ * source code.
+ *
+ * Note that people who make modified versions of this module
+ * are not obligated to grant this special exception for their
+ * modified versions; it is their choice whether to do so.  The GNU
+ * General Public License gives permission to release a modified
+ * version without this exception; this exception also makes it
+ * possible to release a modified version which carries forward this
+ * exception.
+ *
+ */
+
+#include "ll.h"
+#include "mac.h"
+#include "MAC_GRP11.h"
+#include "random.h"
+
+// Added by Sushmita to support event tracing (singal@nunki.usc.edu)
+#include "agent.h"
+#include "basetrace.h"
+
+#include "cmu-trace.h"
+
+static class MAC_GRP11Class : public TclClass {
+public:
+	MAC_GRP11Class() : TclClass("Mac/MAC_GRP11") {}
+	TclObject* create(int, const char*const*) {
+		return new MAC_GRP11();
+	}
+} class_MAC_GRP11;
+
+
+// Added by Sushmita to support event tracing (singal@nunki.usc.edu).
+void MAC_GRP11::trace_event(char *eventtype, Packet *p)
+{
+	if (et_ == NULL) return;
+	char *wrk = et_->buffer();
+	char *nwrk = et_->nbuffer();
+
+	hdr_ip *iph = hdr_ip::access(p);
+	char *src_nodeaddr =
+		Address::instance().print_nodeaddr(iph->saddr());
+	char *dst_nodeaddr =
+		Address::instance().print_nodeaddr(iph->daddr());
+
+	if (wrk != 0) 
+	{
+		sprintf(wrk, "E -t "TIME_FORMAT" %s %s %s",
+			et_->round(Scheduler::instance().clock()),
+			eventtype,
+			src_nodeaddr,
+			dst_nodeaddr);
+	}
+	if (nwrk != 0)
+	{
+		sprintf(nwrk, "E -t "TIME_FORMAT" %s %s %s",
+		et_->round(Scheduler::instance().clock()),
+		eventtype,
+		src_nodeaddr,
+		dst_nodeaddr);
+	}
+	et_->dump();
+}
+
+MAC_GRP11::MAC_GRP11() : Mac() {
+	
+	rx_state_ = tx_state_ = MAC_IDLE;
+	tx_active_ = 0;
+	waitTimer = new MAC_GRP11WaitTimer(this);
+	sendTimer = new MAC_GRP11SendTimer(this);
+	recvTimer = new MAC_GRP11RecvTimer(this);
+	// Added by Sushmita to support event tracing (singal@nunki.usc.edu)
+	bind("rval_", &rval_);
+	bind("duration_", &duration_);
+	et_ = new EventTrace();
+	busy_ = 0;
+	bind("fullduplex_mode_", &fullduplex_mode_);
+}
+
+// Added by Sushmita to support event tracing (singal@nunki.usc.edu)
+int 
+MAC_GRP11::command(int argc, const char*const* argv)
+{
+	if (argc == 3) {
+		if(strcmp(argv[1], "eventtrace") == 0) {
+			et_ = (EventTrace *)TclObject::lookup(argv[2]);
+			return (TCL_OK);
+		}
+	}
+	return Mac::command(argc, argv);
+}
+
+void MAC_GRP11::recv(Packet *p, Handler *h) {
+
+	struct hdr_cmn *hdr = HDR_CMN(p);
+	/* let MacSimple::send handle the outgoing packets */
+	if (hdr->direction() == hdr_cmn::DOWN) {
+		send(p,h);
+		return;
+	}
+
+	/* handle an incoming packet */
+
+	/*
+	 * If we are transmitting, then set the error bit in the packet
+	 * so that it will be thrown away
+	 */
+	
+	// in full duplex mode it can recv and send at the same time
+	if (!fullduplex_mode_ && tx_active_)
+	{
+		hdr->error() = 1;
+
+	}
+
+	/*
+	 * check to see if we're already receiving a different packet
+	 */
+	
+	if (rx_state_ == MAC_IDLE) {
+		/*
+		 * We aren't already receiving any packets, so go ahead
+		 * and try to receive this one.
+		 */
+		rx_state_ = MAC_RECV;
+		pktRx_ = p;
+		/* schedule reception of the packet */
+		recvTimer->start(txtime(p));
+	} else {
+		/*
+		 * We are receiving a different packet, so decide whether
+		 * the new packet's power is high enough to notice it.
+		 */
+		if (pktRx_->txinfo_.RxPr / p->txinfo_.RxPr
+			>= p->txinfo_.CPThresh) {
+			/* power too low, ignore the packet */
+			Packet::free(p);
+		} else {
+			/* power is high enough to result in collision */
+			rx_state_ = MAC_COLL;
+
+			/*
+			 * look at the length of each packet and update the
+			 * timer if necessary
+			 */
+
+			if (txtime(p) > recvTimer->expire()) {
+				recvTimer->stop();
+				Packet::free(pktRx_);
+				pktRx_ = p;
+				recvTimer->start(txtime(pktRx_));
+			} else {
+				Packet::free(p);
+			}
+		}
+	}
+}
+
+
+double
+MAC_GRP11::txtime(Packet *p)
+ {
+	 struct hdr_cmn *ch = HDR_CMN(p);
+	 double t = ch->txtime();
+	 if (t < 0.0)
+	 	t = 0.0;
+	 return t;
+ }
+
+
+
+
+void MAC_GRP11::send(Packet *p, Handler *h)
+{
+	hdr_cmn* ch = HDR_CMN(p);
+
+	/* store data tx time */
+ 	ch->txtime() = Mac::txtime(ch->size());
+
+	// Added by Sushmita to support event tracing (singal@nunki.usc.edu)
+	trace_event("SENSING_CARRIER",p);
+
+	/* check whether we're idle */
+
+
+
+	
+	double mdelay = 0;
+
+	// generate repeatTx_ number of random delays
+	double* delay = new double[rval_];
+	for (int i = 0; i < rval_; i++) {
+	    delay[i] = (rand() % RAND_MAX) / (double)RAND_MAX * duration_;
+	    //printf("%f is the delay",delay[i]);
+	    if (delay[i] > mdelay) {
+		mdelay = delay[i];
+	    }
+	}
+
+	// use dummy tx handler for first repeatTx_-1 packets
+	for (int i = 0; i < rval_; i++) {
+	    if (delay[i] != mdelay) {
+		Scheduler::instance().schedule(this, (Event*)p->copy(), delay[i]);
+	    }
+	}
+	delete delay;
+
+	waitTimer->restart(mdelay);
+		if (tx_state_ != MAC_IDLE) {
+		
+		Packet::free(p);
+		return;
+	}
+		pktTx_ = p;
+	txHandler_ = h;
+	if(rx_state_ != MAC_IDLE) {
+        trace_event("BACKING_OFF",p);
+    }
+	if (rx_state_ == MAC_IDLE ) {
+	    // we're idle, so start sending now
+		waitTimer->restart(mdelay);
+	    sendTimer->restart(mdelay + ch->txtime());
+	} else {
+	    // we're currently receiving, so schedule it after
+	    // we finish receiving
+		waitTimer->restart(mdelay);
+	    sendTimer->restart(mdelay + ch->txtime()
+		    + HDR_CMN(pktRx_)->txtime());
+	}
+}
+
+
+void MAC_GRP11::recvHandler()
+{
+	hdr_cmn *ch = HDR_CMN(pktRx_);
+	Packet* p = pktRx_;
+	MacState state = rx_state_;
+	pktRx_ = 0;
+	int dst = hdr_dst((char*)HDR_MAC(p));
+	
+	//busy_ = 0;
+
+	rx_state_ = MAC_IDLE;
+
+	// in full duplex mode we can send and recv at the same time
+	// as different chanels are used for tx and rx'ing
+	if (!fullduplex_mode_ && tx_active_) {
+		// we are currently sending, so discard packet
+		Packet::free(p);
+	} else if (state == MAC_COLL) {
+		// recv collision, so discard the packet
+		drop(p, DROP_MAC_COLLISION);
+		//Packet::free(p);
+	} else if (dst != index_ && (u_int32_t)dst != MAC_BROADCAST) {
+		
+		/*  address filtering
+		 *  We don't want to log this event, so we just free
+		 *  the packet instead of calling the drop routine.
+		 */
+		Packet::free(p);
+	} else if (ch->error()) {
+		// packet has errors, so discard it
+		//Packet::free(p);
+		drop(p, DROP_MAC_PACKET_ERROR);
+	
+	} else {
+		uptarget_->recv(p, (Handler*) 0);
+	}
+}
+
+void MAC_GRP11::waitHandler()
+{
+	tx_state_ = MAC_SEND;
+	tx_active_ = 1;
+
+	downtarget_->recv(pktTx_, txHandler_);
+}
+
+void MAC_GRP11::sendHandler()
+{
+	Handler *h = txHandler_;
+	Packet *p = pktTx_;
+
+	pktTx_ = 0;
+	txHandler_ = 0;
+	tx_state_ = MAC_IDLE;
+	tx_active_ = 0;
+
+	//busy_ = 1;
+	//busy_ = 0;
+	
+	
+	// I have to let the guy above me know I'm done with the packet
+	h->handle(p);
+}
+
+
+
+//  Timers
+
+void MAC_GRP11Timer::restart(double time)
+{
+	if (busy_)
+		stop();
+	start(time);
+}
+
+	
+
+void MAC_GRP11Timer::start(double time)
+{
+	Scheduler &s = Scheduler::instance();
+
+	assert(busy_ == 0);
+	
+	busy_ = 1;
+	stime = s.clock();
+	rtime = time;
+	assert(rtime >= 0.0);
+
+	s.schedule(this, &intr, rtime);
+}
+
+void MAC_GRP11Timer::stop(void)
+{
+	Scheduler &s = Scheduler::instance();
+
+	assert(busy_);
+	s.cancel(&intr);
+	
+	busy_ = 0;
+	stime = rtime = 0.0;
+}
+
+
+void MAC_GRP11WaitTimer::handle(Event *)
+{
+	busy_ = 0;
+	stime = rtime = 0.0;
+
+	mac->waitHandler();
+}
+
+void MAC_GRP11SendTimer::handle(Event *)
+{
+	busy_ = 0;
+	stime = rtime = 0.0;
+
+	mac->sendHandler();
+}
+
+void MAC_GRP11RecvTimer::handle(Event *)
+{
+	busy_ = 0;
+	stime = rtime = 0.0;
+
+	mac->recvHandler();
+}
+
+void
+MAC_GRP11::handle(Event* p) {
+    downtarget_->recv((Packet*)p, txHandler_);
+}
diff -ruN ns-allinone-2.35/ns-2.35/mac/MAC_GRP11.cc~ ns-allinone-2.35_modified/ns-2.35/mac/MAC_GRP11.cc~
--- ns-allinone-2.35/ns-2.35/mac/MAC_GRP11.cc~	1969-12-31 19:00:00.000000000 -0500
+++ ns-allinone-2.35_modified/ns-2.35/mac/MAC_GRP11.cc~	2016-12-18 22:32:56.039698000 -0500
@@ -0,0 +1,397 @@
+
+/*
+ * MAC_GRP11.cc
+ * Copyright (C) 2003 by the University of Southern California
+ * $Id: mac-simple.cc,v 1.8 2010/03/08 05:54:52 tom_henderson Exp $
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
+ *
+ *
+ * The copyright of this module includes the following
+ * linking-with-specific-other-licenses addition:
+ *
+ * In addition, as a special exception, the copyright holders of
+ * this module give you permission to combine (via static or
+ * dynamic linking) this module with free software programs or
+ * libraries that are released under the GNU LGPL and with code
+ * included in the standard release of ns-2 under the Apache 2.0
+ * license or under otherwise-compatible licenses with advertising
+ * requirements (or modified versions of such code, with unchanged
+ * license).  You may copy and distribute such a system following the
+ * terms of the GNU GPL for this module and the licenses of the
+ * other code concerned, provided that you include the source code of
+ * that other code when and as the GNU GPL requires distribution of
+ * source code.
+ *
+ * Note that people who make modified versions of this module
+ * are not obligated to grant this special exception for their
+ * modified versions; it is their choice whether to do so.  The GNU
+ * General Public License gives permission to release a modified
+ * version without this exception; this exception also makes it
+ * possible to release a modified version which carries forward this
+ * exception.
+ *
+ */
+
+#include "ll.h"
+#include "mac.h"
+#include "MAC_GRP11.h"
+#include "random.h"
+
+// Added by Sushmita to support event tracing (singal@nunki.usc.edu)
+#include "agent.h"
+#include "basetrace.h"
+
+#include "cmu-trace.h"
+
+static class MAC_GRP11Class : public TclClass {
+public:
+	MAC_GRP11Class() : TclClass("Mac/MAC_GRP11") {}
+	TclObject* create(int, const char*const*) {
+		return new MAC_GRP11();
+	}
+} class_MAC_GRP11;
+
+
+// Added by Sushmita to support event tracing (singal@nunki.usc.edu).
+void MAC_GRP11::trace_event(char *eventtype, Packet *p)
+{
+	if (et_ == NULL) return;
+	char *wrk = et_->buffer();
+	char *nwrk = et_->nbuffer();
+
+	hdr_ip *iph = hdr_ip::access(p);
+	char *src_nodeaddr =
+		Address::instance().print_nodeaddr(iph->saddr());
+	char *dst_nodeaddr =
+		Address::instance().print_nodeaddr(iph->daddr());
+
+	if (wrk != 0) 
+	{
+		sprintf(wrk, "E -t "TIME_FORMAT" %s %s %s",
+			et_->round(Scheduler::instance().clock()),
+			eventtype,
+			src_nodeaddr,
+			dst_nodeaddr);
+	}
+	if (nwrk != 0)
+	{
+		sprintf(nwrk, "E -t "TIME_FORMAT" %s %s %s",
+		et_->round(Scheduler::instance().clock()),
+		eventtype,
+		src_nodeaddr,
+		dst_nodeaddr);
+	}
+	et_->dump();
+}
+
+MAC_GRP11::MAC_GRP11() : Mac() {
+	
+	rx_state_ = tx_state_ = MAC_IDLE;
+	tx_active_ = 0;
+	waitTimer = new MAC_GRP11WaitTimer(this);
+	sendTimer = new MAC_GRP11SendTimer(this);
+	recvTimer = new MAC_GRP11RecvTimer(this);
+	// Added by Sushmita to support event tracing (singal@nunki.usc.edu)
+	bind("rval_", &rval_);
+	bind("duration_", &duration_);
+	et_ = new EventTrace();
+	busy_ = 0;
+	bind("fullduplex_mode_", &fullduplex_mode_);
+}
+
+// Added by Sushmita to support event tracing (singal@nunki.usc.edu)
+int 
+MAC_GRP11::command(int argc, const char*const* argv)
+{
+	if (argc == 3) {
+		if(strcmp(argv[1], "eventtrace") == 0) {
+			et_ = (EventTrace *)TclObject::lookup(argv[2]);
+			return (TCL_OK);
+		}
+	}
+	return Mac::command(argc, argv);
+}
+
+void MAC_GRP11::recv(Packet *p, Handler *h) {
+
+	struct hdr_cmn *hdr = HDR_CMN(p);
+	/* let MacSimple::send handle the outgoing packets */
+	if (hdr->direction() == hdr_cmn::DOWN) {
+		send(p,h);
+		return;
+	}
+
+	/* handle an incoming packet */
+
+	/*
+	 * If we are transmitting, then set the error bit in the packet
+	 * so that it will be thrown away
+	 */
+	
+	// in full duplex mode it can recv and send at the same time
+	if (!fullduplex_mode_ && tx_active_)
+	{
+		hdr->error() = 1;
+
+	}
+
+	/*
+	 * check to see if we're already receiving a different packet
+	 */
+	
+	if (rx_state_ == MAC_IDLE) {
+		/*
+		 * We aren't already receiving any packets, so go ahead
+		 * and try to receive this one.
+		 */
+		rx_state_ = MAC_RECV;
+		pktRx_ = p;
+		/* schedule reception of the packet */
+		recvTimer->start(txtime(p));
+	} else {
+		/*
+		 * We are receiving a different packet, so decide whether
+		 * the new packet's power is high enough to notice it.
+		 */
+		if (pktRx_->txinfo_.RxPr / p->txinfo_.RxPr
+			>= p->txinfo_.CPThresh) {
+			/* power too low, ignore the packet */
+			Packet::free(p);
+		} else {
+			/* power is high enough to result in collision */
+			rx_state_ = MAC_COLL;
+
+			/*
+			 * look at the length of each packet and update the
+			 * timer if necessary
+			 */
+
+			if (txtime(p) > recvTimer->expire()) {
+				recvTimer->stop();
+				Packet::free(pktRx_);
+				pktRx_ = p;
+				recvTimer->start(txtime(pktRx_));
+			} else {
+				Packet::free(p);
+			}
+		}
+	}
+}
+
+
+double
+MAC_GRP11::txtime(Packet *p)
+ {
+	 struct hdr_cmn *ch = HDR_CMN(p);
+	 double t = ch->txtime();
+	 if (t < 0.0)
+	 	t = 0.0;
+	 return t;
+ }
+
+
+
+
+void MAC_GRP11::send(Packet *p, Handler *h)
+{
+	hdr_cmn* ch = HDR_CMN(p);
+
+	/* store data tx time */
+ 	ch->txtime() = Mac::txtime(ch->size());
+
+	// Added by Sushmita to support event tracing (singal@nunki.usc.edu)
+	trace_event("SENSING_CARRIER",p);
+
+	/* check whether we're idle */
+
+
+
+	
+	double mdelay = 0;
+
+	// generate repeatTx_ number of random delays
+	double* delay = new double[rval_];
+	for (int i = 0; i < rval_; i++) {
+	    delay[i] = (rand() % RAND_MAX) / (double)RAND_MAX * duration_;
+	    //printf("%f is the delay",delay[i]);
+	    if (delay[i] > mdelay) {
+		mdelay = delay[i];
+	    }
+	}
+
+	// use dummy tx handler for first repeatTx_-1 packets
+	for (int i = 0; i < rval_; i++) {
+	    if (delay[i] != mdelay) {
+		Scheduler::instance().schedule(this, (Event*)p->copy(), delay[i]);
+	    }
+	}
+	delete delay;
+
+	waitTimer->restart(mdelay);
+		if (tx_state_ != MAC_IDLE) {
+		
+		Packet::free(p);
+		return;
+	}
+		pktTx_ = p;
+	txHandler_ = h;
+	if(rx_state_ != MAC_IDLE) {
+        trace_event("BACKING_OFF",p);
+    }
+	if (rx_state_ == MAC_IDLE ) {
+	    // we're idle, so start sending now
+		waitTimer->restart(mdelay);
+	    sendTimer->restart(mdelay + ch->txtime());
+	} else {
+	    // we're currently receiving, so schedule it after
+	    // we finish receiving
+		waitTimer->restart(mdelay);
+	    sendTimer->restart(mdelay + ch->txtime()
+		    + HDR_CMN(pktRx_)->txtime());
+	}
+}
+
+
+void MAC_GRP11::recvHandler()
+{
+	hdr_cmn *ch = HDR_CMN(pktRx_);
+	Packet* p = pktRx_;
+	MacState state = rx_state_;
+	pktRx_ = 0;
+	int dst = hdr_dst((char*)HDR_MAC(p));
+	
+	//busy_ = 0;
+
+	rx_state_ = MAC_IDLE;
+
+	// in full duplex mode we can send and recv at the same time
+	// as different chanels are used for tx and rx'ing
+	if (!fullduplex_mode_ && tx_active_) {
+		// we are currently sending, so discard packet
+		Packet::free(p);
+	} else if (state == MAC_COLL) {
+		// recv collision, so discard the packet
+		drop(p, DROP_MAC_COLLISION);
+		//Packet::free(p);
+	} else if (dst != index_ && (u_int32_t)dst != MAC_BROADCAST) {
+		
+		/*  address filtering
+		 *  We don't want to log this event, so we just free
+		 *  the packet instead of calling the drop routine.
+		 */
+		Packet::free(p);
+	} else if (ch->error()) {
+		// packet has errors, so discard it
+		//Packet::free(p);
+		drop(p, DROP_MAC_PACKET_ERROR);
+	
+	} else {
+		uptarget_->recv(p, (Handler*) 0);
+	}
+}
+
+void MAC_GRP11::waitHandler()
+{
+	tx_state_ = MAC_SEND;
+	tx_active_ = 1;
+
+	downtarget_->recv(pktTx_, txHandler_);
+}
+
+void MAC_GRP11::sendHandler()
+{
+	Handler *h = txHandler_;
+	Packet *p = pktTx_;
+
+	pktTx_ = 0;
+	txHandler_ = 0;
+	tx_state_ = MAC_IDLE;
+	tx_active_ = 0;
+
+	//busy_ = 1;
+	//busy_ = 0;
+	
+	
+	// I have to let the guy above me know I'm done with the packet
+	h->handle(p);
+}
+
+
+
+//  Timers
+
+void MAC_GRP11Timer::restart(double time)
+{
+	if (busy_)
+		stop();
+	start(time);
+}
+
+	
+
+void MAC_GRP11Timer::start(double time)
+{
+	Scheduler &s = Scheduler::instance();
+
+	assert(busy_ == 0);
+	
+	busy_ = 1;
+	stime = s.clock();
+	rtime = time;
+	assert(rtime >= 0.0);
+
+	s.schedule(this, &intr, rtime);
+}
+
+void MAC_GRP11Timer::stop(void)
+{
+	Scheduler &s = Scheduler::instance();
+
+	assert(busy_);
+	s.cancel(&intr);
+	
+	busy_ = 0;
+	stime = rtime = 0.0;
+}
+
+
+void MAC_GRP11WaitTimer::handle(Event *)
+{
+	busy_ = 0;
+	stime = rtime = 0.0;
+
+	mac->waitHandler();
+}
+
+void MAC_GRP11SendTimer::handle(Event *)
+{
+	busy_ = 0;
+	stime = rtime = 0.0;
+
+	mac->sendHandler();
+}
+
+void MAC_GRP11RecvTimer::handle(Event *)
+{
+	busy_ = 0;
+	stime = rtime = 0.0;
+
+	mac->recvHandler();
+}
+
+void
+MAC_GRP11::handle(Event* p) {
+    downtarget_->recv((Packet*)p, txHandler_);
+}
diff -ruN ns-allinone-2.35/ns-2.35/mac/MAC_GRP11.h ns-allinone-2.35_modified/ns-2.35/mac/MAC_GRP11.h
--- ns-allinone-2.35/ns-2.35/mac/MAC_GRP11.h	1969-12-31 19:00:00.000000000 -0500
+++ ns-allinone-2.35_modified/ns-2.35/mac/MAC_GRP11.h	2016-12-17 05:46:38.442448000 -0500
@@ -0,0 +1,143 @@
+
+/*
+ * mac-simple.h
+ * Copyright (C) 2003 by the University of Southern California
+ * $Id: mac-simple.h,v 1.6 2005/08/25 18:58:07 johnh Exp $
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
+ *
+ *
+ * The copyright of this module includes the following
+ * linking-with-specific-other-licenses addition:
+ *
+ * In addition, as a special exception, the copyright holders of
+ * this module give you permission to combine (via static or
+ * dynamic linking) this module with free software programs or
+ * libraries that are released under the GNU LGPL and with code
+ * included in the standard release of ns-2 under the Apache 2.0
+ * license or under otherwise-compatible licenses with advertising
+ * requirements (or modified versions of such code, with unchanged
+ * license).  You may copy and distribute such a system following the
+ * terms of the GNU GPL for this module and the licenses of the
+ * other code concerned, provided that you include the source code of
+ * that other code when and as the GNU GPL requires distribution of
+ * source code.
+ *
+ * Note that people who make modified versions of this module
+ * are not obligated to grant this special exception for their
+ * modified versions; it is their choice whether to do so.  The GNU
+ * General Public License gives permission to release a modified
+ * version without this exception; this exception also makes it
+ * possible to release a modified version which carries forward this
+ * exception.
+ *
+ */
+
+#ifndef ns_mac_grp11_h
+#define ns_mac_grp11_h
+
+// Added by Sushmita to support event tracing (singal@nunki.usc.edu)
+#include "address.h"
+#include "ip.h"
+
+class MAC_GRP11WaitTimer;
+class MAC_GRP11SendTimer;
+class MAC_GRP11RecvTimer;
+
+// Added by Sushmita to support event tracing (singal@nunki.usc.edu)
+class EventTrace;
+
+
+class MAC_GRP11 : public Mac {
+	//Added by Sushmita to support backoff
+	friend class BackoffTimer;
+public:
+	MAC_GRP11();
+	void recv(Packet *p, Handler *h);
+	void send(Packet *p, Handler *h);
+	void handle(Event* e);
+	void waitHandler(void);
+	void sendHandler(void);
+	void recvHandler(void);
+	double txtime(Packet *p);
+
+	// Added by Sushmita to support event tracing (singal@nunki.usc.edu)
+	void trace_event(char *, Packet *);
+	int command(int, const char*const*);
+	EventTrace *et_;
+	int rval_;
+	double duration_;
+private:
+	Packet *	pktRx_;
+	Packet *	pktTx_;
+        MacState        rx_state_;      // incoming state (MAC_RECV or MAC_IDLE)
+	MacState        tx_state_;      // outgoing state
+        int             tx_active_;
+	int             fullduplex_mode_;
+	Handler * 	txHandler_;
+	MAC_GRP11WaitTimer *waitTimer;
+	MAC_GRP11SendTimer *sendTimer;
+	MAC_GRP11RecvTimer *recvTimer;
+
+	int busy_ ;
+
+
+};
+
+class MAC_GRP11Timer: public Handler {
+public:
+	MAC_GRP11Timer(MAC_GRP11* m) : mac(m) {
+	  busy_ = 0;
+	}
+	virtual void handle(Event *e) = 0;
+	virtual void restart(double time);
+	virtual void start(double time);
+	virtual void stop(void);
+	inline int busy(void) { return busy_; }
+	inline double expire(void) {
+		return ((stime + rtime) - Scheduler::instance().clock());
+	}
+
+protected:
+	MAC_GRP11	*mac;
+	int		busy_;
+	Event		intr;
+	double		stime;
+	double		rtime;
+	double		slottime;
+};
+
+// Timer to use for delaying the sending of packets
+class MAC_GRP11WaitTimer: public MAC_GRP11Timer {
+public: MAC_GRP11WaitTimer(MAC_GRP11 *m) : MAC_GRP11Timer(m) {}
+	void handle(Event *e);
+};
+
+//  Timer to use for finishing sending of packets
+class MAC_GRP11SendTimer: public MAC_GRP11Timer {
+public:
+	MAC_GRP11SendTimer(MAC_GRP11 *m) : MAC_GRP11Timer(m) {}
+	void handle(Event *e);
+};
+
+// Timer to use for finishing reception of packets
+class MAC_GRP11RecvTimer: public MAC_GRP11Timer {
+public:
+	MAC_GRP11RecvTimer(MAC_GRP11 *m) : MAC_GRP11Timer(m) {}
+	void handle(Event *e);
+};
+
+
+
+#endif
diff -ruN ns-allinone-2.35/ns-2.35/mac/MAC_GRP11.h~ ns-allinone-2.35_modified/ns-2.35/mac/MAC_GRP11.h~
--- ns-allinone-2.35/ns-2.35/mac/MAC_GRP11.h~	1969-12-31 19:00:00.000000000 -0500
+++ ns-allinone-2.35_modified/ns-2.35/mac/MAC_GRP11.h~	2016-12-17 04:37:37.209099000 -0500
@@ -0,0 +1,84 @@
+#define ns_mac_simple_h
+#include "address.h"
+#include "ip.h"
+class MAC_GRP11WaitTimer;
+class MAC_GRP11SendTimer;
+class MAC_GRP11RecvTimer;
+class EventTrace;
+
+
+class MAC_GRP11 : public Mac {
+	friend class BackoffTimer;
+public:
+	MAC_GRP11();
+	void recv(Packet *p, Handler *h);
+	void send(Packet *p, Handler *h);
+
+	void waitHandler(void);
+	void sendHandler(void);
+	void recvHandler(void);
+	double txtime(Packet *p);
+
+	void trace_event(char *, Packet *);
+	int command(int, const char*const*);
+	EventTrace *et_;
+
+private:
+	Packet *	pktRx_;
+	Packet *	pktTx_;
+        MacState        rx_state_;      // incoming state (MAC_RECV or MAC_IDLE)
+	MacState        tx_state_;      // outgoing state
+        int             tx_active_;
+	int             fullduplex_mode_;
+	int 		interval_;
+	int 		repeatTx_;
+	Handler * 	txHandler_;
+	MAC_GRP11WaitTimer *waitTimer;
+	MAC_GRP11SendTimer *sendTimer;
+	MAC_GRP11RecvTimer *recvTimer;
+
+	int busy_ ;
+
+
+};
+
+class MAC_GRP11Timer: public Handler {
+public:
+	MAC_GRP11Timer(MAC_GRP11* m) : mac(m) {
+	  busy_ = 0;
+	}
+	virtual void handle(Event *e) = 0;
+	virtual void restart(double time);
+	virtual void start(double time);
+	virtual void stop(void);
+	inline int busy(void) { return busy_; }
+	inline double expire(void) {
+		return ((stime + rtime) - Scheduler::instance().clock());
+	}
+
+protected:
+	MAC_GRP11	*mac;
+	int		busy_;
+	Event		intr;
+	double		stime;
+	double		rtime;
+	double		slottime;
+};
+
+class MAC_GRP11WaitTimer: public MAC_GRP11Timer {
+public: MAC_GRP11WaitTimer(MAC_GRP11 *m) : MAC_GRP11Timer(m) {}
+	void handle(Event *e);
+};
+
+class MAC_GRP11SendTimer: public MAC_GRP11Timer {
+public:
+	MAC_GRP11SendTimer(MAC_GRP11 *m) : MAC_GRP11Timer(m) {}
+	void handle(Event *e);
+};
+
+// Timer to use for finishing reception of packets
+class MAC_GRP11RecvTimer: public MAC_GRP11Timer {
+public:
+	MAC_GRP11RecvTimer(MAC_GRP11 *m) : MAC_GRP11Timer(m) {}
+	void handle(Event *e);
+};
Binary files ns-allinone-2.35/ns-2.35/mac/MAC_GRP11.o and ns-allinone-2.35_modified/ns-2.35/mac/MAC_GRP11.o differ
